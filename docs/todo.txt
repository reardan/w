current:
	type...
		add fields to existing type table
			compiler.compile -> grammar.program -> 
		create type.fields for globals declared
		use the type.fields: for what?
			meta
				name
				size
			imported lookups
				e.g.
				import lib
				lib.println("hiya!")

		test on a sample type
		use type.w as it's own type
		use type.w as the basis for other types
		change import so it doesn't import globals
			> import type
				this will conflict with a lot of names
				> import type as language_type
				or only import in relevant files?
				> private import type
			type.size

	range...
	debugging...
		print_stack()
			get_esp():
				mov eax,esp
				ret
			print_words(esp, 20)
			even better would be
				get_context():
					popad
		sys_signal
		segv handler
		stack parser
		virtual memory
	net...
		split socket / connect
		server
			bind
			listen
			accept
		udp


major bugs:
	int*[]
	*(char*)
	struct*
	&
	int* = int?

	function pointers...
		local variable calls work
		passing as arguments doesn't work
			need a better typing system to handle this


most important:
	import subdirectory
	type
	new
	symbol
	dict
	range
	repl
	debugger or emit info


features:
	types
	generators
	iterators
	for in range()
	class instantiation
	subdirectory import
	cli argument parsing
	debugging info
	debugger
		asm
		disasm
	stream class
	file class
	template strings
	int80 -> sysenter
	x64
	windows
	make
	git
	editor
	mocking
	variable arguments
	default values
	template
	var - dynamic typing
	inline asm (functions?)
	refactor
		rename
		extract
		break
		combine
	dynamic typing
	parse c headers
		build structs
		enum values


test:
	&
	*
	!
	[] for int* / other
	char* indirection

statment:
	new
	for
	in
	range
	yield
	and
	or
	not

data structures:
	list
	dict
	string
	matrix

types:
	float
	const modifier
	*
	dynamic

